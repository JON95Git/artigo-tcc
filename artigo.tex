\documentclass[times, twoside, watermark]{artigo}
\usepackage{blindtext}
\usepackage[utf8]{inputenc}
\citebrackets[]
\usepackage{indentfirst}
\renewcommand\refname{}
% \documentclass[article, 12pt, oneside, a4paper, twocolumn]{abntex2}
% \usepackage[left=3cm,top=3cm,right=2cm,bottom=2cm]{geometry}
% \usepackage[alf, abnt-etal-list=0, abnt-etal-cite=3]{abntex2cite}
% \usepackage{authblk}
% \usepackage{amsmath}
% \usepackage{amsfonts}
% \usepackage{amssymb}
% \usepackage{graphicx}
% \usepackage{verbatim}
% \usepackage{titlesec}

\begin{document}

% -------------------------------Titulo---------------------------------------------

\title{\Large {Desenvolvimento de firmware robusto e multiplataforma}}

\author[1]{Jonathan Gonzaga}
\author[2]{Orientador}

\affil[1]{Graduando em Engenharia de Computação, UNISAL São José - Campinas,
  \href{mailto:jonathan.s.gonzaga@gmail.com}{jonathan.s.gonzaga@gmail.com}}
\affil[2]{Professor do UNISAL São José - Campinas,
  \href{mailto:orientador@sj.unisal.br}{orientador@sj.unisal.br}}

\maketitle

% -------------------------------Resumo-Abstract-------------------------------------

\noindent\begin{abstract}
\textit{Resumo -} \normalfont{\textit{Este artigo apresenta técnicas e ferramentas
    para o desenvolvimento de firmware robusto e multiplataforma, com o intuito de
    minimizar bugs, permitir a implementação de testes unitários e incentivar o estudo de
    conceitos de Engenharia de software aplicados a sistemas embarcados.
    É utilizada uma aplicação de exemplo, uma interface gráfica para requisição de amostras de números verdadeiramente aleatórios (TRNG - True Random Number Generator), capaz de rodar em ambiente desktop e embarcado.}}
\end {abstract}

\noindent\begin{keywords}
  \textit{\textbf{Palavras-chave: }}\normalfont{\textit{sitemas embarcados, firmware,
      TDD, testes unitários}}
\end{keywords}

\noindent\begin{abstract}
\textit{Abstract - } \normalfont{\textit{This article presents techniques and tools
    for robust and multiplatform firmware development, in order to minimize bugs, allow
    the implementation of unit tests and encourage the study of software engineering
    concepts applied to embedded systems.
    An example application is used, a graphical interface for requesting samples of truly random numbers (TRNG - True Random Number Generator), capable of running in both desktop and embedded environments.}}
\end {abstract}
\noindent\begin{keywords}
  \textit{\textbf{Keywords: }}\normalfont{\textit{embedded systems, firmware, TDD, unit
      tests}}
\end{keywords}
%\hfill\

% -------------------------------INTRODUÇÃO-----------------------------------------

\section{INTRODUÇÃO }

Com o avanço da eletrônica e da computação, a miniaturização de circuitos integrados
e a redução de custos de fabricação, surgiram na indústria diversos dispositivos
eletrônicos com poder de processamento.
A maioria desses dispositivos conta com processadores, memórias e periféricos
integrados, de forma que seu \textit{software} é destinado e \textit{embarcado}
em uma aplicação específica. Sistemas dessa natureza são conhecidos como
\textit{sistemas embarcados}.

Produtos como eletrodomésticos, eletrônicos em geral, equipamentos médicos,
equipamentos de telecomunicações, ferramentas eletrônicas, sistemas de controle
e automação e sistemas de tempo real em veículos são ou possuem sistemas embarcados
em sua concepção.

Devido ao alto nível de criticidade de alguns sistemas embarcados, é esperado que o
\textit{software} executado neles seja altamente confiável e com o mínimo de
\textit{bugs} possível.
A realidade da indústria de eletrônicos mostra que essa afirmação nem sempre é
verdadeira.

Erros e falhas de \textit{software} são um problema em diversas áreas da tecnologia.
Desde vulnerabilidades que facilitam a ação de \textit{hackers} em redes sociais,
falhas em \textit{smartphones} que causam travamento do sistema operacional a
inconsistências no acionamento de sistemas de freios que causam acidentes em
veículos. Esse último caso é ainda mais grave, pois o sistema lida diretamente com
vidas humanas.

Especialistas em desenvolvimento de \textit{firmware} e \textit{software} embarcado,
como Jack Ganssle, James W. Grenning e Jacob Beningo, dedicaram-se a criar
literatura de qualidade, escrevendo livros e artigos com técnicas e
metodologias de desenvolvimento de \textit{software}.
Alguns títulos relevantes são: \textit{Test-Driven development for Embedded C}
\cite{tddembeddedc},
\textit{The Art of Designing Embedded Systems}\cite{ganssle2008art} e
\textit{Reusable Firmware Development}\cite{beningo2017reusable}.
A partir dessas obras muito se tem discutido sobre como criar sistemas mais seguros,
com menor probabilidade de erros e menos suscetíveis a má utilização por parte do
usuário.

No processo de desenvolvimento de \textit{software}, o custo de uma alteração no
código tende a ficar maior conforme  as etapas do desenvolvimento avançam, por isso
o custo de um \textit{bug} encontrado em campo após o produto ser lançado, é muito
maior que o custo do mesmo sendo encontrado ainda na fase de
desenvolvimento\cite{firmwarecost}.
Esse cenário por si só já mostra a necessidade de se detectar problemas nas fases
iniciais do projeto.

\textit{Software} para sistemas embarcados muitas vezes é difícil de ser testado e
validado, extremamente dependente da plataforma de \textit{hardware target}, e
tende a demonstrar problemas de integração com outras
partes do sistema após a inserção de novas funcionalidades.
Devido a limitação de recursos e a extrema dependência do \textit{hardware}, testes
automatizados não são realizados, o que acaba prejudicando a qualidade do código.

Metodologias e conceitos como \textit{TDD (Test-Driven development)}, pirâmide de
testes e \textit{SOLID}, são historicamente e erroneamente atribuídos apenas
aos \textit{softwares} de "alto nível", como \textit{web} ou
\textit{mobile} por exemplo, afastando os desenvolvedores de \textit{software}
embarcado desses conceitos e da utilização de abstrações mais inteligentes.

Com essas dificuldades em mente, percebe-se a necessidade de se estimular as boas
práticas de desenvolvimento de \textit{software} embarcado, a utilização de testes
automatizados e independentes do \textit{hardware}, e o estudo de conceitos de
engenharia de \textit{software} que auxiliem na
redução de \textit{bugs} e consequentemente, redução de custos do projeto e aumento
da qualidade do código gerado. \hfill\\



% ----------------------REFERENCIAL TEÓRICO-----------------------------------

\section{REFERENCIAL TEÓRICO}

\subsection{Firmware}\hfill\\

\textit{Firmware} é um tipo específico de \textit{software} executado diretamente
num circuito integrado (ou \textit{chip}).
Não necessita de outros programas para ser executado (como sistemas operacionais),
além de servir a um propósito único.
Em outras palavras, é o \textit{software} executado em um sistema
embarcado\cite{ganssle2004firmware}.

Devido a limitações de tamanho e recursos desse tipo de sistema,
o \textit{firmware} precisa manipular o \textit{hardware} diretamente e toda a sua
arquitetura costuma ser voltada a eventos do mundo externo.

Diferente de sistemas computacionais mais complexos e com alto nível de abstração,
onde geralmente o \textit{kernel} do sistema operacional é modularizado e abstrai
o acesso a dispositivos de \textit{hardware}\cite{tanenbaum2015modern},
num sistema embarcado o \textit{firmware} é responsável pela gerência dos recursos
e eventos de \textit{hardware} (interrupções e exceções do processador) e também
pelo código da aplicação (regras de negócio, interface com usuário e demais
especificidades).

Muitas vezes ele faz parte de um sistema computacional maior,
por exemplo, computadores \textit{desktop} possuem circuitos integrados para
aplicações específicas, como a \textit{BIOS} (\textit{Basic Input/Output System}),
que trata-se de um mecanismo responsável pela inicialização dos
componentes de \textit{hardware} do computador. \cite{terzicbasic}

Algumas literaturas não fazem distinção entres os termos \textit{firmware} e
\textit{software embarcado}, sendo ambos utilizados como sinônimos. Por uma
questão de organização, será realizada uma distinção entre
esses termos: \textit{firmware} é o \textit{software} executado num circuito
integrado comumente escrito em linguagem \textit{C, C++}, ou mesmo \textit{Assembly}.
Já o \textit{software embarcado} possui características de alta abstração,
sendo uma aplicação (um processo rodando num sistema operacional,
geralmente baseado em \textit{GNU/Linux})\cite{simmonds2015mastering} porém executado
em dispositivos de propósito específico (como roteadores e terminais de
autoatendimento).
Pode ser escrito em linguagens de programação como \textit{C, C++, Rust, Go, Python}
entre outras.

Em um sistema embarcado executando um \textit{firmware}, o cérebro por trás de todo o
processamento é um componente chamado \textit{microcontrolador}.

\subsection{Microcontroladores}\hfill\\

Microcontroladores são processadores de pequeno porte contendo \textit{CPU},
memórias (\textit{RAM} e \textit{FLASH}) e demais
recursos atrelados no mesmo encapsulamento ou \textit{SoC (System on Chip)}.
Esses recursos são denominados periféricos, e são inclusos no \textit{chip}
com o intuito de tornar possível o interfaceamento entre a \textit{CPU}
e o mundo externo, permitir a comunicação com outros dispositivos e
aquisitar dados para posterior processamento através dos pinos físicos do componente.

Os recursos mais comuns são as interfaces de comunicação
serial (\textit{USART, I2C, SPI}), conversores analógico-digital e digital-analógico
(\textit{ADC} e \textit{DAC}), temporizadores/contadores (\textit{TIMERS}) e
interface de pinos (\textit{GPIO}).

Com tamanho e custo reduzidos em comparação ao microprocessadores,
os microcontroladores tornam-se economicamente viáveis, além da
escolha óbvia, para controlar digitalmente dispositivos e
processos\cite{gridling2007introduction}.


\subsection{Linguagem de programação - \textit{C}}\hfill\\

\textit{C} é uma linguagem de programação procedural de propósito geral que
suporta programação estruturada, escopo de variável lexical e recursão, com um
sistema de tipo estático. Por design, \textit{C} fornece construções que mapeiam de
forma eficiente para instruções de máquina típicas. Dispõe de compiladores para a
maioria das arquiteturas de computador e sistemas operacionais
existentes.\cite{ritchie1993development}

Devido a essas características, vem  sendo utilizada em aplicações previamente
codificados em linguagem \textit{assembly}.
Algumas dessas aplicações são: sistemas operacionais, compiladores,
\textit{drivers} de dispositivos, bibliotecas com acesso a \textit{hardware} e
sistemas embarcados.

Leva esse nome por ser sucessora da linguagem de programação \textit{B}.
Foi desenvolvida no \textit{Bell Labs} por Dennis Ritchie entre 1972 e 1973 para
construir utilitários rodando em \textit{Unix}.
Em 1989 foi padronizada pelo \textit{ANSI} (\textit{ANSI C}) e pela
\textit{International Organization for Standardization (ISO)}.
\cite{ritchie1993development}

\subsection{Testes de \textit{software}}\hfill\\

Testes de \textit{software} são procedimentos pelos quais o código fonte de um
\textit{software} é submetido afim de validar seu comportamento mediante
os requisitos pelos quais foi projetado.

Existem diversos tipos de testes de \textit{software}, cada um responsável por
testar partes e situações diferentes. A chamada \textit{Pirâmide de testes}
\cite{contan2018test} foi concebida com o intuito de seguimentar os testes em três
grandes níveis:

\begin{itemize}
\itemsep0em 
  \item \textit{Testes end-to-end} - simulam a aplicação final
  \item \textit{Testes de integração} - testa a integração entre testes de unidade
  \item \textit{Testes unitários} - testes de unidade, verificam a menor unidade de
        código testável
\end{itemize}

Apenas o último nível, os testes unitários, serão abordados nesse documento.

\subsection{Testes unitários}\hfill\\

Testes unitários são a base dos testes de \textit{software}. Na \textit{Pirâmide de
  testes} encontram-se no nível mais baixo, o que indica que são
o tipo mais barato e fácil de implementar\cite{contan2018test},
fazendo com que sejam os mais numerosos em relação aos demais tipos de teste.

Como seu nome sugere, são testes de \textit{unidade}, onde é possível testar a
menor unidade testável do código (sejam funções, classes ou módulos).

\subsection{\textit{TDD - Test-Driven development}}\hfill\\

\textit{Test-Driven development} (ou \textit{Desenvolvimento orientado a testes}) é
uma técnica incremental de construção de \textit{software}.
Nessa técnica, nenhum código de produção é escrito sem que primeiro seja escrito um
teste unitário que falhe na primeira execução.

Ao contrário da prática comum de desenvolvimento de \textit{software}, onde primeiro
é desenvolvido o código de produção e só depois os testes, no \textit{TDD}
o desenvolvedor expressa o comportamento desejado do código em um teste.
O teste é executado e falha. Só então ele escreve o código de produção, fazendo o
teste passar.
A automação de testes é a chave para o \textit{TDD}. Os testes são pequenos e
automatizados.
A cada nova funcionalidade implementada, novos testes unitários são escritos,
seguidos imediatamente por um código de produção que satisfaça aqueles testes.

Conforme o código de produção cresce, também crescem em conjunto os testes unitários,
que são ativos tão valiosos quanto o próprio código de produção.
A cada mudança de código, o conjunto de testes é executado, verificando a
funcionalidade da nova implementação, mas também a compatibilidade com o código já
existente\cite{tddembeddedc}.

Um esquema simplificado do \textit{TDD} é apresentado na Figura \ref{fig:tdd}.\hfill\

\begin{figure}[H]
  \centering
  \caption{Esquema simplificado do TDD}
  \includegraphics[width=0.95\linewidth]{images/tdd.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:tdd}
\end{figure}

Três grandes etapas são necessárias: \textit{Teste falha}, \textit{Teste passa}
e \textit{Refatora}. Na primeira, são escritos apenas os testes unitários, com base
nos requisitos do projeto, porém sem nenhum código de produção ainda, o que
obviamente fará com que os testes falhem após a execução.

Logo após, são escritos apenas os trechos de código necessários para que aqueles
testes passem e nada mais.

Na última etapa, o código passará pelo processo de \textit{refatoração}, onde serão
eliminados possíveis erros, duplicidade, e será formatado de acordo com o padrão
requisitado.


\subsection{\textit{Framework} de testes - \textit{Unity}}\hfill\\

\textit{Unity} é um \textit{framework} de testes escrito em linguagem C, pensado
principalmente para \textit{software} em sistemas embarcados.

Trabalha com o conceito de \textit{asserts}, que nada mais são que formas de se
garantir e verificar parâmetros (entrada) e resultados (saída) de funções no código
fonte.\cite{unity}


\subsection{Ferramenta de dublês de testes - \textit{CMock}}\hfill\\

\textit{CMock} é uma ferramenta de dublês de testes, usada para simular o
comportamento de funções que possuam dependência externa (\textit{hardware} ou
bibliotecas externas).

Trabalha com os conceitos de \textit{mocks} e \textit{stubs},
que nada mais são que funções \textit{fake}, criadas com o intuito de emular o
comportamento (entradas e saídas) de componentes do código que tenham alguma
dependência.\cite{cmock}

\subsection{\textit{Build system - Ceedling}}\hfill\\

\textit{Ceedling} é um \textit{build system} (sistema de construção de
\textit{software}) para projetos escritos em linguagem C.
É uma espécie de extensão do sistema de construção \textit{Rake (make-ish)} do
\textit{Ruby}.
O \textit{Ceedling} é voltado principalmente para o
\textit{Desenvolvimento Orientado a Testes (TDD)} em linguagem C e reune o
\textit{framework} de testes \textit{Unity}, a ferramenta de dublês de testes
\textit{CMock} e a ferramenta de manipulação de exceções \textit{CException} - três
outros projetos de código aberto que auxiliam na dinâmica de testes
automatizados\cite{gomes2016uttos}.

\subsection{Sistema operacional de tempo real - \textit{FreeRTOS}}\hfill\\

\textit{FreeRTOS} é um \textit{kernel} de tempo real,
ou um sistema operacional de tempo real (\textit{Real-Time Operating System})
para dispositivos embarcados. Foi desenvolvido para ser pequeno, simples e portável.
Seu \textit{kernel} é composto por apenas 3 arquivos em linguagem C.
O \textit{FreeRTOS} permite a fácil implementação de multitarefa preemptiva
ou não preemptiva com diversos níveis de prioridade de
tarefas\cite{zhu2016understanding}.\hfill\\

\subsection{\textit{Build system - GNU Make}}\hfill\\

\textit{GNU Make} é um \textit{build system} (sistema de construção de
\textit{software}) que controla a geração de executáveis de um \textit{software}
a partir dos arquivos de código fonte.

A ferramenta \textit{Make} recebe as instruções de como construir o programa a partir
de um arquivo chamado \textit{makefile}, que lista cada um dos arquivos de código
fonte e os comandos para transformá-los em executáveis.

Ao escrever um programa, deve-se escrever um \textit{makefile} para ele, de modo
que seja possível usar o \textit{Make} para construção e execução do mesmo.
\cite{gnumake}

\subsection{Compilador - \textit{GCC}}\hfill\\

O \textit{GNU Compiler Collection (GCC)} é um compilador de otimização produzido pelo
\textit{Projeto GNU} que oferece suporte a várias linguagens de programação,
arquiteturas de \textit{hardware} e sistemas operacionais.

A \textit{Free Software Foundation (FSF)} distribui o \textit{GCC} como
\textit{software livre} sob a licença \textit{GNU General Public License (GNU GPL)}.
O \textit{GCC} é um componente chave da cadeia de ferramentas \textit{GNU} e o
compilador padrão para a maioria dos projetos relacionados ao \textit{GNU} e ao
\textit{kernel Linux}.\cite{gcc}


\subsection{Editor de textos - \textit{Visual Studio Code}}\hfill\\

O \textit{Visual Studio Code} é um editor de código-fonte \textit{freeware} feito
pela \textit{Microsoft} para \textit{Windows}, \textit{Linux} e \textit{macOS}. Os
recursos incluem suporte para depuração, destaque de sintaxe, autocompletar de código
inteligente, \textit{snippets}, refatoração de código e \textit{Git}
incluso.\cite{vscode}

\subsection{Biblioteca gráfica - \textit{LVGL}}\hfill\\

\textit{LVGL} é um biblioteca gráfica \textit{open source} para desenvolvimento
de interfaces gráficas em sistemas embarcados. Escrita em linguagem C, pode ser usada 
em microcontroladores ou microprocessadores. 
A bilioteca dispõe de um simulador para desenvolvimento da interface sem 
a necessidade do \textit{hardware} dedicado, permitindo a execução de código em
ambiente \textit{desktop}.\cite{lvgl}

\subsection{\textit{TRNG - True Random Number Generator}}\hfill\\

Um gerador de números verdadeiramente aleatórios, ou \textit{TRNG - True Random 
Number Generator} é um circuito capaz de gerar números aleatórios através
de algum processo físico ao invés dos métodos convencionais de uso de algoritmos.
Alguns dos possíveis fenômenos físicos que podem ser utilizados para esse fim são:
\begin{itemize}
  \item Ruído térmico
  \item Ruído analógico
  \item Fenômeno fotoelétrico
  \item Fenômeno quântico
\end{itemize}

O objetivo da geração de números verdadeiramente aleatórios remete ao uso da 
criptografia, como geração de chaves criptográficas.

Os periféricos \textit{TRNG} presentes em microcontroladores são 
implementados em silício, num circuito que utiliza os ruídos analógicos de 
alimentação e temperatura.\cite{vasyltsov2008fast}

% ----------------------METODOLOGIA-----------------------------------
\section{METODOLOGIA}

\subsection{MATERIAIS E MÉTODOS}\hfill\\
%Reseta o contador de subsection
% \setcounter{section}{-1}\stepcounter{section}

Serão utilizadas as seguintes ferramentas de \textit{software} na execução do projeto:

\begin{itemize}
\itemsep0em
  \item \textit{FreeRTOS} - sistema operacional de tempo real
  \item \textit{GNU make} - \textit{Build system} para compilação do código de produção
  \item \textit{GCC(x86)} e \textit{GCC(arm)}- compiladores para ambas arquiteturas
  \item \textit{VS Code} - editor de textos
  \item \textit{Ceedling} - \textit{Build system} para compilação e execução dos testes
  \item \textit{Unity} - \textit{framework} de testes
  \item \textit{Cmock} - ferramenta de dublê de testes
  \item \textit{LVGL} - Biblioteca gráfica
\end{itemize}

A metodologia utilizada para o desenvolvimento do projeto segue a técnica de
\textit{TDD} descrita anteriormente.

Nas três etapas (\textit{Teste falha}, \textit{Teste passa}
e \textit{Refatora}) serão utilizadas ferramentas e mecanismos de \textit{software}
para auxílio na implementação dos testes, execução e automatização de processos \hfill\

% ----------------------DESENVOLVIMENTO-----------------------------------

\subsection{DESENVOLVIMENTO}\hfill\\

%Reseta o contador de subsections
% \setcounter{section}{-1}\stepcounter{section}
O processo de desenvolvimento do projeto seguiu o padrão especificado anteriormente,
juntamente com algumas regras e boas práticas:

\begin{itemize}
\itemsep0em 
  \item \textit{Clean Code} (Código limpo) - o código precisa ser de fácil
        entendimento\cite{martin2009clean}
  \item \textit{KISS (Keep it simple stupid)} - as soluções implementadas precisam ser
        simples\cite{martin2018clean}
  \item \textit{SOLID principles} - seguir os padrões do \textit{SOLID}
        \cite{martin2002agile}
  \item \textit{Boy Scout Principle} (Regra do escoteiro) - \textit{"Deixe o campo mais
          limpo do que quando o encontrou"} - Sempre deixe o código melhor do antes de você
        trabalhar nele\cite{martin2009clean}
  \item \textit{Refactoring} (Refatoração) - o código precisa ser refatorado e
        aprimorado constatemente\cite{martin2009clean}
\end{itemize}

\subsubsection{Definindo a aplicação e suas funcionalidades}\hfill\\

A aplicação escolhida para demonstração das técnicas trata-se de uma interface
gráfica para geração de números verdadeiramente aleatórios (\textit{TRNG - True 
Random Number Generator}).

Essa interface gráfica será executada em dois ambientes diferentes: embarcado e 
\textit{desktop}. As funcionalidades, interfaces de aplicação (\textit{API - 
application programming interface}) e visual serão exatamente os mesmos, variando-se
apenas as implementações de código dependente de plataforma. 

Haverão duas abas disponíveis para o usuário, a primeira, chamada de \textit{Mass 
storage}, permitirá que seja salvo um arquivo no sistema de arquivos de 
tamanho e nomes a serem escolhidos pelo usuário. Essa aba conterá uma caixa de texto 
para receber o nome do arquivo, um \textit{spinbox} para se definir o tamanho do 
arquivo, e um botão de salvar.

A segunda aba chamada de \textit{Random}, permitirá que o usuário escolha um limite
mínimo e máximo, e ao clicar em \textit{Get random}, irá obter um número aleatório
dentro desse limite anteriomente definido. Essa aba conterá dois \textit{spinbox}
para escolha dos valores mínimo e máximo, e uma \textit{label} para mostrar o 
resultado.

\subsubsection{Definindo os casos de teste}\hfill\\

A prática do \textit{TDD} exige que os requisitos de um \textit{software}
estejam muito bem definidos desde o início para que se possa começar a escrever 
os testes, por isso é necessário que se defina uma lista de testes, como a descrita 
abaixo:

Testes na aba \textit{Mass storage}:

\begin{itemize}
\itemsep0em 
\item Checar a sanidade do \textit{RNG} (dados não devem se repetir com frequência)
\item Checar tamanho do nome do arquivo (deve respeitar o limite do sistema de arquivos)
\item Checar se o arquivo foi realmente criado
\end{itemize}

Testes na aba \textit{Random}:

\begin{itemize}
\itemsep0em 
\item Checar se os limites mínimo e máximo são respeitados (mínimo deve ser menor que máximo)
\item Checar se o resultado dado realmente está no intervalo definido
\end{itemize}

\subsubsection{Arquitetura de \textit{software} do sistema}\hfill\\

Os componentes de \textit{software} separados por nível de abstração estão ilustrados
na Figura \ref{fig:arch2}.\hfill\\

\begin{figure}[H]
  \centering
  \caption{Arquitetura de software do projeto}
  \includegraphics[width=0.9\linewidth]{images/arch2.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:arch2}
\end{figure}

A camada de \textit{Aplicação} faz uso dos \textit{Drivers} para controle dos
periféricos de \textit{hardware}, utiliza o \textit{RTOS} para criar e gerenciar
\textit{threads} e recursos compartilhados por elas e as \textit{Bibliotecas}
fornecem alguma funcionalidade extra como o \textit{file system} (sistema de 
arquivos) e a biblioteca gráfica \textit{LVGL}.

\subsubsection{Camadas de abstração - \textit{drivers}, Bibliotecas e \textit{RTOS}}\hfill\\

Um dos pilares do desenvolvimento de \textit{software} multiplataforma é a abstração.
Utilizar interfaces bem definidas a partir de \textit{header files} (arquivos de
extensão \textit{.h}), variando apenas a implementação dessas interfaces nos
\textit{source files} (arquivos de extensão \textit{.c}).

Para se escrever código portável é extremamente necessário a não dependência de
\textit{Drivers}, \textit{RTOS - (Real Time Operating Systems)} e demais bibliotecas

A abordagem consiste em criar camadas de abstração que acessem essas camadas, como
pode ser visto na Figura \ref{fig:arch-abs}: \hfill\\

\begin{figure}[H]
  \centering
  \caption{Arquitetura de software com abstrações}
  \includegraphics[width=0.9\linewidth]{images/arch-abs.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:arch-abs}
\end{figure}

Essas camadas são apenas funções que encapsulam as funções dos módulos originais,
fazendo com que o código da \textit{Aplicação} nunca realize uma chamada de função
diretamente a esses componentes, mas sim as suas abstrações. A prática da escrita de código dessa maneira é chamada de \textit{Dual-targeting}.

\subsubsection{Dual-targeting: compilando para duas arquiteturas}\hfill\\

O processo de \textit{Dual-targeting} exige independência
entre os módulos de \textit{software} e principalmente da arquitetura de 
\textit{hardware}.
Escrever \textit{software} embarcado independente de arquitetura exige claro
entendimento dos limites entre o código da aplicação e demais códigos (bibliotecas, 
\textit{drivers}).

\subsubsection{Abstraindo um módulo com dependência}\hfill\\

O módulo de \textit{RNG} responsável pelo aquisição de amostras de números 
verdadeiramente aleatórios, é dependente da implementação de \textit{driver},
portantto, é dependente de \textit{hardware}, 
Este módulo é um \textit{driver} e está localizado na camada de mesmo nome, sua 
interface e implementação estão representadas
nas Figuras \ref{fig:rng.h} e \ref{fig:rng.c}.\hfill\

\begin{figure}[H]
  \centering
  \caption{Interface do módulo de \textit{RNG} - \textit{rng.h}}
\begin{lstlisting}[language=C]
#ifndef __RNG_H__
#define __RNG_H__

void rng_init(rng_config_st *rng);
uint8_t rng_get(rng_config_st *rng);

#endif
\end{lstlisting}
  \label{fig:rng.h}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}


\begin{figure}[H]
  \centering
  \caption{Implementação do módulo de \textit{RNG} - \textit{rng.c}}
\begin{lstlisting}[language=C]
#include "rng.h"

void rng_init(rng_config_st *rng)
{
    // Acesso a registradores de hardware
    RNG->periph.cfg_st = rng;
}

uint8_t rng_get(rng_config_st *rng))
{
    // Acesso a registradores de hardware
    return RNG->periph.data;
}

\end{lstlisting}
  \label{fig:rng.c}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

O módulo contém funções que dependem do \textit{hardware}, porém as mesmas não
devem ser chamadas diretamente pela aplicação, mas sim por uma camada de abstração
mostrada nas Figuras \ref{fig:rng_user.h} e \ref{fig:rng_user.c}.\hfill\\

\begin{figure}[H]
  \centering
  \caption{Interface pública do módulo - \textit{rng\_user.h}}
\begin{lstlisting}[language=C]
#ifndef __RNG_USER_H__
#define __RNG_USER_H__

void rng_user_init(rng_config_st *rng);
uint8_t rng_user_get(rng_config_st *rng);

#endif
\end{lstlisting}
  \label{fig:rng_user.h}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

\begin{figure}[H]
  \centering
  \caption{Implementação da abstração para acesso ao módulo de \textit{RNG}
\textit{rng\_user.c}}
\begin{lstlisting}[language=C]
#include "rng_user.h"

// Inclui header do modulo original
#include "rng.h"

void rng_user_init(rng_config_st *rng)
{
    // Chama funcao do modulo original
    rng_init(rng);
}

uint8_t rng_user_get(rng_config_st *rng)
{
    // Chama funcao do modulo original
    return rng_get(rng);
}

\end{lstlisting}
  \label{fig:rng_user.c}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

A abstração do módulo, chamada de \textit{rng\_user.c e rng\_user.h} abstrai o
acesso, permitindo que seja feita a utilização de dublês de testes (\textit{mocks,
fakes e stubs}), visando a implementação de testes unitários.

A aplicação final faz uso apenas do módulo de abstração, como apresentado na Figura 
\ref{fig:main.c}:\hfill\\

\begin{figure}[H]
  \centering
  \caption{Camada de aplicação - \textit{main.c}}
\begin{lstlisting}[language=C, caption=]
#include <stdio.h>
// Camada de aplicacao nao inclui o modulo
// diretamente, mas sim sua abstracao
#include "rng_user.h"
#define RNG_SAMPLES 32

int main(void)
{	
	rng_config_st rng;
	rng_user_init(&rng);
	uint8_t rng_buffer[RNG_SAMPLES];
    
	// Loop infinito
	while (1) {
		// Obtem 32 amostras de RNG
		for (int i = 0; i < RNG_SAMPLES; i++) {
			rng_buffer[i] = rng_user_get(&rng);
		}
	}
    return 0;
}
\end{lstlisting}
  \label{fig:main.c}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

\subsubsection{Implementando testes unitários}\hfill\\

A implementação de testes unitários exige a utilização de um \textit{framework}
de testes. Foi utilizado o \textit{Unity}, ferramenta já contida no 
\textit{Ceedling}.
Usando os comandos do próprio \textit{build system} para a criação
do projeto, tem-se a seguinte linha de comando apresentada na 
Figura \ref{fig:ceedling-new}.\hfill\\

\begin{figure}[H]
  \centering
  \caption{Criando um projeto com o \textit{Ceedling}}
\begin{lstlisting}[language=bash]
$ ceedling new projeto-exemplo
\end{lstlisting}
  \label{fig:ceedling-new}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

É criada uma estrutura de diretórios semelhante a mostrada na Figura \ref{fig:ceedling-new-dir}. \hfill\\

\begin{figure}[H]
  \centering
  \caption{Estrutura de diretórios criada pelo \textit{Ceedling}}
\begin{forest}
  for tree={
  font=\ttfamily,
  grow'=0,
  child anchor=west,
  parent anchor=south,
  anchor=west,
  calign=first,
  inner xsep=7pt,
  edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
    },
  % style for your file node 
  file/.style={edge path={\noexpand\path [draw, \forestoption{edge}]
          (!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
      inner xsep=2pt,font=\small\ttfamily
    },
  before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
  fit=band,
  before computing xy={l=15pt},
  }
  [projeto-exemplo
  [build]
  [src]
  [test]
  [project.yml, file]
  ]
\end{forest}
  \label{fig:ceedling-new-dir}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

\begin{itemize}
\itemsep0em 
  \item \textit{build} - contém os artefatos de \textit{software}, arquivos 
temporários e executáveis
  \item \textit{src} - contém o código fonte da aplicação
  \item \textit{test} - contém o código fonte dos testes
  \item \textit{project.yml} - contém a configuração relativa ao projeto
\end{itemize}

Para criar o primeiro módulo, utiliza-se \textit{ceedling module:create} passando o 
nome do módulo como argumento, como mostra a Figura \ref{fig:ceedling-module}:

\begin{figure}[H]
  \centering
  \caption{Criando um módulo com o \textit{Ceedling}}
\begin{lstlisting}[language=bash]
$ ceedling module:create[rng]
\end{lstlisting}
  \label{fig:ceedling-module}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

A ferramenta criará arquivos \textit{source} e \textit{header} em \textit{src} e um
arquivo de testes em \textit{test} como mostrado na Figura \ref{fig:ceedling-dir}:
\hfill\\

\begin{figure}[H]
  \centering
  \caption{Estrutura de diretórios com arquivos criados}
\begin{forest}
  for tree={
  font=\ttfamily,
  grow'=0,
  child anchor=west,
  parent anchor=south,
  anchor=west,
  calign=first,
  inner xsep=7pt,
  edge path={
      \noexpand\path [draw, \forestoption{edge}]
      (!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
    },
  % style for your file node 
  file/.style={edge path={\noexpand\path [draw, \forestoption{edge}]
          (!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
      inner xsep=2pt,font=\small\ttfamily
    },
  before typesetting nodes={
      if n=1
        {insert before={[,phantom]}}
        {}
    },
  fit=band,
  before computing xy={l=15pt},
  }
  [projeto-exemplo
  [build]
  [src
    [rng.c, file]
    [rng.h, file]
  ]
  [test
    [test\_rng.c, file]
  ]
  [project.yml, file]
  ]
\end{forest}
  \label{fig:ceedling-dir}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

No arquivo de testes, são criadas as funções, \textit{setUp()} e
\textit{tearDown()} (funções necessárias para o \textit{framework Unity}) 
e adicionado o \textit{header file unity.h}, como 
mostra a Figura \ref{fig:tests-init}:\hfill\

\begin{figure}[H]
  \centering
  \caption{Arquivo de testes inicial - \textit{test\_rng.c}}
\begin{lstlisting}[language=C]
#include "unity.h"
#include "rng.h"

void setUp(void)
{
}

void tearDown(void)
{
}

void test_rng_NeedToImplement(void)
{
	TEST_IGNORE_MESSAGE("Need to Implement rng");
}
\end{lstlisting}
  \label{fig:tests-init}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

Utilizando as abstrações demonstradas anteriormente, os primeiros testes podem ser
implementados, como demonstrado na Figura \ref{fig:simple-test}:\hfill\\

\begin{figure}[H]
  \centering
  \caption{Arquivo de testes com um teste simples  - \textit{test\_rng.c}}
\begin{lstlisting}[language=C]
#include "unity.h"
#include "rng.h"

void setUp(void)
{
	rng_config_st rng;
	rng_user_init(&rng);	
}

void tearDown(void)
{
}

void test_rng(void)
{	
	uint8_t rng_buffer;
	rng_buffer = rng_user_get();
	TEST_ASSERT_NOT_EQUAL(0, rng_buffer);
}
\end{lstlisting}
  \label{fig:simple-test}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

\subsubsection{Utilizando dublês de teste}\hfill\\

Dublês de teste são utilizados nos casos em que há dependência de algum componente
externo e o módulo precisa ser testado. O \textit{driver} de \textit{RNG} é um
exemplo de dependência de \textit{hardware}, nesse caso, é interessante o uso
de dublês de teste. A ferramenta responsável pela geração desses dublês é o
\textit{Cmock}. A Figura \ref{fig:mock-test} mostra um simples exemplo de utilização:
\hfill\\

\begin{figure}[H]
  \centering
  \caption{Arquivo de testes com mock - \textit{test\_rng\_user.c}}
\begin{lstlisting}[language=C]
#include "unity.h"
#include "mock_rng_user.h"
#include <stdlib.h>

// Callback chamada pelo Cmock
int rng_user_get_callback(int cmock_num_calls)
{
	// Usa funao rand() da linguagem C
	return rand();
}

void test_rng(void)
{
	uint8_t rng_buffer;

	// Registrando a callback
	rng_user_get_StubWithCallback(rng_user_get_callback);
       
	rng_buffer = rng_user_get();
	TEST_ASSERT_NOT_EQUAL(0, rng_buffer);
}
\end{lstlisting}
  \label{fig:mock-test}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

No código anterior uma função de \textit{callback} é definida e registrada no
\textit{Cmock}, de modo que toda vez que a função original for chamada,
\textit{rng\_user\_read()}, a ferramenta redireciona a chamada para
\textit{rng\_user\_read\_callback()}. Para isso é necessário apenas incluir
o \textit{header file} com o prefixo \textit{mock\_}: \textit{mock\_rng\_user.h}.

O argumento \textit{cmock\_num\_calls} na \textit{callback} é uma obrigatoriedade
da ferramenta, para que haja o controle do número de chamadas realizadas a
\textit{callback}.

A Figura \ref{fig:ceedling-output} mostra a saída do comando resultado da execução
do teste de \textit{RNG}:\hfill\\

\begin{figure}[H]
  \centering
  \caption{Rodando o primeiro teste com \textit{Ceedling}}
\begin{lstlisting}[language=bash]
$ ceedling test:rng_user
Test 'test_rng_user.c'
------------------------------
Generating include list for rng_user.h...
Creating mock for rng_user...
Generating runner for test_rng_user.c...
Compiling test_rng_user_runner.c...
Compiling test_rng_user.c...
Compiling mock_rng_user.c...
Compiling unity.c...
Compiling rng_user.c...
Compiling cmock.c...
Linking rng_user.out...
Running rng_user.out...

--------------------
OVERALL TEST SUMMARY
--------------------
TESTED:  1
PASSED:  1
FAILED:  0
IGNORED: 0
\end{lstlisting}
  \label{fig:ceedling-output}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

\subsubsection{Desenvolvendo a interface gráfica}\hfill\\

O processo de desenvolvimento da interface gráfica foi realizado utilizando a 
biblioteca \textit{LVGL} e sua funcionalidade de simulador. Dessa forma, todo o 
\textit{design} da aplicação foi criado de forma independente de \textit{hardware},
reforçando a prática de \textit{dual-targeting}.

Por questões técnicas, a interface gráfica exige que seja feita uma atualização
síncrona a cada 5 ms (milisegundos), o que impossibilita a implementação de testes 
unitários.

Devido a essa limitação, a aplicação gráfica foi definida e implementada antes da 
lógica de negócio da aplicação completa.

As abas anteriormente definidas, \textit{Mass storage} e \textit{Random} são 
mostradas a seguir. A primeira aba é mostrada na Figura 
\ref{fig:mass-storage}.\hfill\

\begin{figure}[H]
  \centering
  \caption{Aba \textit{Mass storage}}
  \includegraphics[width=0.95\linewidth]{images/mass-storage-screen.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:mass-storage}
\end{figure}

A segunda aba é mostrada na Figura \ref{fig:random}.\hfill\

\begin{figure}[H]
  \centering
  
  \caption{Aba \textit{Random}}
  \includegraphics[width=0.95\linewidth]{images/random-screen.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:random}
\end{figure}

\subsubsection{Executando a aplicação em ambiente desktop}\hfill\\

Executar a aplicação apartir do simulador da biblioteca gráfica permite que sejam
utilizadas as abstrações para sistema de arquivos e \textit{RNG} criadas 
anteriormente.

A lógica da aplicação pode ser testada e validada no \textit{host} antes de ser
testada no \textit{target}.

A saída da execução dos testes unitários pode ser vista na 
Figura \ref{fig:ceedling-output-all}.\hfill\

\begin{figure}[H]
  \centering
  \caption{Rodando todos os testes}
\begin{lstlisting}[language=bash]
$ ceedling test:all
Test 'test_app.c'
-----------------
Running test_app.out...


Test 'test_portable.c'
----------------------
Compiling test_portable.c...
Linking test_portable.out...
Running test_portable.out...


Test 'test_rng_user.c'
----------------------
Compiling test_rng_user_runner.c...
Compiling test_rng_user.c...
Linking test_rng_user.out...
Running test_rng_user.out...

--------------------
OVERALL TEST SUMMARY
--------------------
TESTED:  12
PASSED:  12
FAILED:   0
IGNORED:  0
\end{lstlisting}
  \label{fig:ceedling-output-all}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
\end{figure}

\subsubsection{Executando a aplicação em ambiente embarcado}\hfill\\

Nesse ponto, a aplicação, sua lógica e suas partes independentes de plataforma já 
foram testadas e validadas, restando apenas testar as especificidades do
\textit{target}, como detalhes de implementação de \textit{drivers}, arquitetura
do processador e execução das \textit{threads} do \textit{RTOS}.

A execução da primeira aba no \textit{target} é mostrada na 
Figura \ref{fig:random}.\hfill\

\begin{figure}[H]
  \centering
  \caption{Aba \textit{Mass storage}}
  \includegraphics[width=0.95\linewidth]{images/mass-storage-screen-embedded.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:mass-storage-embedded}
\end{figure}

A segunda aba é mostrada na Figura \ref{fig:random-embedded}.\hfill\

\begin{figure}[H]
  \centering
  
  \caption{Aba \textit{Random}}
  \includegraphics[width=0.95\linewidth]{images/random-screen-embedded.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:random-embedded}
\end{figure}

\subsubsection{\textit{Code coverage} - cobertura de código dos testes}\hfill\\

O \textit{framework} de testes utilizado possui uma ferramenta de verificação 
de cobertura de código dos testes (\textit{code coverage}). A ferramenta permite 
avaliar quais trechos de código foram de fato submetidos aos testes ou não.
Essa é uma das métricas disponíveis para se avaliar a efetividade dos testes de 
código.

Na Figura \ref{fig:code-coverage} são exibidos os dados de cobertura de código 
dos módulos. \hfill\\

\begin{figure}[H]
  \centering
  \caption{Cobertura de código dos testes}
  \includegraphics[width=1\linewidth]{images/code-coverage-2.png}
  \caption*{\newline\textbf{Fonte:} acervo do autor}
  \label{fig:code-coverage}
\end{figure}

% ----------------------CONCLUSÃO-----------------------------------

\section{CONCLUSÃO}\hfill\\
Conclui-se que a utilização das técnicas apresentadas permite um processo de
desenvolvimento de \textit{firmware} eficiente (pois todas as funcionalidades são
previamente pensadas), portável e testável, além de considerável redução de tempo de
\textit{debug} pois o código é submetido a testes periodicamente.

A constante utilização do \textit{TDD} alinhada as boas práticas de programação
como \textit{Clean Code} e \textit{SOLID}, agregam não somente a qualidade
do produto final, mas também aos desenvolvedores, elevando o nível técnico 
das equipes.

A utilização das ferramentas de teste apresentadas proporcionam ao desenvolvedor
uma clara visão dos possíveis \textit{bugs} introduzidos e permitem que os mesmos
sejam corrigidos ainda em tempo de desenvolvimento.

Com a alta demanda por \textit{firmware} em diversos campos da indústria, é nítida
a importância do investimento em preparo dos times para que seja gerado código 
de qualidade.


% \section{REFERÊNCIAS}
\bibliography{artigo}

\end{document}
